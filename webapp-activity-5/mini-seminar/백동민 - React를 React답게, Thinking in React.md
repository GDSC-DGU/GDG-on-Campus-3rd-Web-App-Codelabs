#### 디자인도 이쁘고 코드도 이쁘게 짤 순 없을까??

이 단순한 생각에서 이 글 시리즈를 작성하게 되었습니다!  
_(대 바이브코딩 시대에, 문서 보고 코드 짜는 멋쟁이가 되고 싶어...)_

---

### 리액트를 직접 만든 사람들은 어떻게 생각하고 만들었을까?

React 공식 문서 [Thinking in React](https://ko.react.dev/learn/thinking-in-react)를 단순히 **컴포넌트 나누는 방법**이 아니라,  
구조와 철학 관점에서 해체 분석해보려 합니다.

**React의 본질적 철학**

- 순수 함수 UI
- 책임 분리
- 단방향 데이터 흐름
- 예측 가능성

이 관점을 기반으로 다음을 얻는 것을 목표로 합니다.

- React가 왜 이런 방식으로 UI 구성을 가이드하는지에 대한 철학적 이유
- 컴포넌트 설계를 감이 아니라 원리 기반 판단으로 전환

---

# 목차

1. Thinking in React 5단계의 나만의 해석
2. 상태 배치(State Architecture)를 판단하는 기준
3. 단방향 데이터 흐름과 예측 가능성 확보

---

# 1. UI = f(state): 왜 이 식이 필요할까?

React를 진지하게 이해하려면 먼저 이 한 줄을 이해해야 한다.

    UI = f(state)

React가 말하고 싶은 핵심은 단순하다.

> UI는 직접 조작하는 대상이 아니라  
> 상태(state)를 넣으면 계산되어 나오는 결과물이어야 한다.

이 식이 왜 필요한지, 그리고 이게 무너지면 어떤 문제가 생기는지부터 정리한다.

---

## 1.1 기존 UI 패턴이 왜 망가지는가 — 상태 지옥

전통적인 UI는 대체로 다음 방식으로 동작했다.

- DOM에서 요소를 찾고
- 이벤트가 발생할 때마다
- class를 붙였다 떼었다
- 텍스트를 바꾸고
- 여러 상태를 수동으로 맞춘다

문제는 상태가 한 곳에 모여 있지 않다는 점이다.

- 일부는 전역 변수
- 일부는 DOM attribute
- 일부는 인스턴스 필드
- 일부는 사용자 입력으로 또 복사됨

결과적으로 이런 불일치가 발생한다.

- 버튼은 활성인데 다른 영역은 비활성
- 모달은 닫혔는데 오버레이는 남아 있음
- 토글 텍스트는 ON인데 실제 값은 false

즉, 실제 상태와 UI가 어긋나는 순간부터 디버깅 난이도가 급상승한다.  
React는 이 문제를 구조적으로 해결하려고 한다.

---

## 1.2 React의 관점 — UI를 함수로 다루기

React는 접근 자체를 바꾼다.

- UI를 어떻게 바꿀지(how)를 쓰지 말고
- 상태라면 UI가 어떻게 생겨야 하는지(what)를 정의하라고 한다

    UI = f(state)

- 입력: 현재 상태(state)
- 출력: 해당 상태의 UI 트리

DOM 조작 절차 대신  
state → UI를 반환하는 함수를 설계한다.

이것이 선언형 UI(Declarative UI)다.

> 상태가 이렇게 생겼다면  
> 화면은 이렇게 보여야 한다를  
> 함수 정의로 고정한다.

---

## 1.3 순수 함수 UI의 세 가지 조건

React가 지향하는 UI는 순수 함수처럼 동작해야 한다.

1. 같은 state → 항상 같은 UI
   - 랜덤, 시간, 전역 mutable 값에 의존하지 않는다

2. UI는 props와 state로만 결정
   - 전역 싱글톤 직접 접근 패턴은 지양

3. 렌더링 과정에 side effect 없음
   - DOM 조작, 네트워크 요청, 로깅은 useEffect에서 처리

이 조건이 지켜질 때 다음이 가능하다.

- 상태만 보고 UI를 예측 가능
- 특정 state로 화면 테스트 가능
- 변경 이유 추론 가능

---

## 1.4 이 식이 설계에 강제하는 구조

UI = f(state)를 적용하면 구조가 바뀐다.

1. 상태는 외부에서 관리하고 주입
   - 컴포넌트는 UI 계산기 역할

2. 렌더링과 effect 분리
   - render와 side effect 단계 분리

3. 컴포넌트는 함수 합성 단위
   - 부모 → props 전달
   - 자식 → props → UI 매핑

전체 앱은 결국 다음 구조다.

    AppUI = f(globalState)

작은 함수들의 합성으로 분해된 형태다.

---

## 1.5 UI = f(state)가 깨질 때의 실패 패턴

### 렌더링 중 전역 수정

- 테스트 불가능
- 변경 추적 불가능

### derived state를 중복 저장

잘못된 예:

    items
    filteredItems

올바른 형태:

    filteredItems = f(items, filter)

중복 상태는 언젠가 불일치한다.

### 렌더링 중 DOM 직접 조작

- React 렌더 사이클과 충돌
- 상태와 실제 DOM 불일치 발생

핵심 요약:

> UI가 state의 함수가 아닐 때  
> UI와 state는 반드시 어긋난다.

---

## 1.6 Thinking in React 5단계의 위치

공식 5단계는 결국 하나의 목적을 가진다.

> 앱을 UI = f(state) 구조로 재조직하는 절차

- 정적 버전 만들기 → 순수 UI 확보
- 최소 상태 찾기 → 입력 최소화
- 상태 위치 결정 → 책임 단위 정의
- 단방향 흐름 → 추적 가능성 확보

---

## 다음 장 예고

다음 질문으로 이어진다.

> state는 어디에 두어야  
> 예측 가능한 시스템이 되는가?

2장의 주제는  
상태 관리 및 책임 단위(State Architecture)이다.

---

## 출처

- https://overreacted.io/the-two-reacts/
- https://overreacted.io/a-complete-guide-to-useeffect/
- https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0
- https://www.youtube.com/watch?v=x7cQ3mrcKaY
