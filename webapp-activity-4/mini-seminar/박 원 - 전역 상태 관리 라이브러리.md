# 박 원 - 전역 상태 관리 라이브러리

### 1) 상태의 종류 정리

## 상태란?

<aside>
🤍 어떤 의미를 지닌 값이며 지속적으로 변경될 수 있는 값

</aside>

🖤 **역할에 따라** 

1. UI 상태 : 상호 작용이 가능한 모든 요소의 현재 값
    
    ex) 다크/라이트 모드, input, 알림창의 노출 여부 등
    
2. 폼 상태 : loading, submit, disabled, validation …
3. 서버에서 가져온 값: 클라이언트에서 서버로 요청을 통해 가져온 값 (API 요청)
4. URL 상태 : 브라우저에 의해 관리되는 상태값
    
    ex) `/mypage/57`
    
5. 등등..

🖤 **범위에 따라** 

1. 지역 상태
    - **`useState`** 훅을 사용하여 관리되는 상태
    - 특정 컴포넌트 안에서만 관리되는 상태
    - 예를 들어, 특정 폼의 입력 값, 특정 컴포넌트의 UI 상태 등
    
2. 전역 상태
    - 애플리케이션 전체에서 공유되는 상태
    - 전역 상태는 주로 상태 관리 라이브러리를 사용하여 관리
    - 예를 들어, 사용자 인증 정보, 테마 설정 등

## Props Drilling

<aside>
🤍 `Prop Drilling` : props를 오로지 하위 컴포넌트로 전달하는 용도로만 쓰이는 컴포넌트들을 거치면서 React Component 트리의 한 부분에서 다른 부분으로 데이터를 전달하는 과정

</aside>

![image.png](%박 원 - 전역 상태 관리 라이브러리/image.png)

- code example
    
    ```tsx
    import React from "react";
    
    const App = () => {
      return (
        <div className="App">
          <FirstComponent content="Who needs me?" />
        </div>
      );
    };
    //firstcomponent는 content가 필요없는데 자식에게 넘겨주기 위해 받고있음 
    const FirstComponent = ({ content }) => {
      return (
        <div>
          <h3>I am the first component</h3>
          <SecondComponent content={content} />
        </div>
      );
    };
    
    const SecondComponent = ({ content }) => {
      return (
        <div>
          <h3>I am the second component</h3>
          <ThirdComponent content={content} />
        </div>
      );
    };
    
    const ThirdComponent = ({ content }) => {
      return (
        <div>
          <h3>I am the third component</h3>
          <ComponentNeedingProps content={content} />
        </div>
      );
    };
    
    const ComponentNeedingProps = ({ content }) => {
      return <h3>{content}</h3>;
    };
    ```
    

✨ **장점** 

1. 컴포넌트 간 데이터를 가장 쉽고 빠르게 전달
2. 값이 어디서 사용되는지 더 명시적이기에 데이터의 흐름을 파악할 수 있다.

🎃 **단점** 

컴포넌트의 뎁스가 깊어져 prop 전달이 지나치게 많아진다면..!

→ prop을 추적하기 점차 힘들어지면서 유지보수가 어려워진다.

- 일부 데이터의 자료형을 바꾸게 되는 경우
- 프로퍼티의 이름이 중간에 변경되어 값을 추적하기 어려운 경우
- 필요보다 적은 프로퍼티를 전달하면서 동시에 `props 기본값`(ex. 함수 매개변수 기본값 등)을 과하게 사용한 결과, 필요한 프로퍼티가 전달되지 않은 상황에서 그 문제를 인지하기 어려운 경우
    
    (참고: 함수 컴포넌트에서는 `defaultProps` 대신 `function Component({ title = "기본 제목" }) { ... }`처럼 **매개변수 기본값**을 쓰는 방식이 현재 React에서 권장!)
    

### 💡 해결 방법

1. 관련된 상태는 최대한 가까이 보관해야 한다. **최소 공통 부모 컴포넌트**에서!
2. `children` 적극 사용
    - code example
        
        ```tsx
        export default function App() {
          const content = "Who needs me?";
          return (
            <div className="App">
              <FirstComponent>
                <SecondComponent>
                  <ThirdComponent>
                    <ComponentNeedingProps content={content} />
                  </ThirdComponent>
                </SecondComponent>
              </FirstComponent>
            </div>
          );
        }
        
        function FirstComponent({ children }) {
          return (
            <div>
              <h3>I am the first component</h3>
              {children}
            </div>
          );
        }
        
        function SecondComponent({ children }) {
          return (
            <div>
              <h3>I am the second component</h3>
              {children}
            </div>
          );
        }
        
        function ThirdComponent({ children }) {
          return (
            <div>
              <h3>I am the third component</h3>
              {children}
            </div>
          );
        }
        
        function ComponentNeedingProps({ content }) {
          return <h3>{content}</h3>;
        }
        
        ```
        
3. **React Context** 
4. **전역 상태관리 라이브러리(Redux Toolkit, Zustand, Jotai, ...)** 
    
    

### 2) 전역 상태 라이브러리가 필요한 순간

- 같은 상태를 N군데에서 읽고/수정해야 한다.
- props로 계속 넘기다 보니 단계가 3단계 이상이다.
- Context만 쓰면  **컴포넌트를 재사용 하기가 매우 힘들어지기** 때문에, 마구 사용하는 건 지양해야 한다
- 최상단 state를 업데이트하면 해당 context를 사용하는 하위 컴포넌트들이 리렌더링
    
    → 치명적인 성능 이슈
    
- 특정 상태를 **어디서 관리하는지 헷갈리기** 시작했다.
- 디버깅으로 분석과정이 필요하다

이 중 2~3개 이상이면 전역 상태 라이브러리 고려해봐야함

### 3) 라이브러리 4개 정리

## Redux

### 중앙집중식 저장소 store를 두고 화면에 필요한 전역상태를 store에 모아두고 관리한다. store, action, reducer로 구성되어있다.

![스크린샷 2025-12-25 오후 3.04.48.png](%EB%B0%95%20%EC%9B%90%20-%20%EC%A0%84%EC%97%AD%20%EC%83%81%ED%83%9C%20%EA%B4%80%EB%A6%AC%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-12-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.04.48.png)

- **사용:** store 만들고 slice 쪼개고 action 정의하고... 할 게 좀 많다.

**장점** 

1. 중앙화된 상태 관리
    
    → 사용자가 어떤 액션을 했고, **어떤 데이터가 변경**되었는지 쉽게 알 수 있기 때문에 앱의 전체 상태를 예측 가능하고 쉽게 관리할 수 있게 해준다.
    
    → 복잡한 앱에서 여러 컴포넌트 간의 상태 공유를 용이하게 만든다.
    
2. 상태 관리 로직 분리
3. 데이터의 일관성

**단점** 

1. 작은 규모의 경우, 사소한 기능이라도 Redux로 구현하려면 너무 많은 부가적인 코드가 필요할 수 있다.
    
    → 보일러플레이트 존재
    → 규모가 큰 서비스에서 사용하는 것이 적합하다!
    
2. 러닝 커브가 높을 수 있다.

```jsx
// store/counterSlice.js
//createSlice로 하나의 상태와 변경 로직을 묶을 수 있음 
import { createSlice, configureStore } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",//슬라이스 이름
  initialState: { value: 0 },//초기상태값
  reducers: {
    // 1. 액션 이름, 생성 함수, 리듀서가 합쳐짐
    // 2. 그냥 값을 대입해도 됨 (내부적으로 알아서 처리함)
    inc: (state) => { state.value += 1; },
    dec: (state) => { state.value -= 1; },
  },
});

export const { inc, dec } = counterSlice.actions;

//스토어 생성
export const store = configureStore({
  reducer: { counter: counterSlice.reducer },
});
```

Redux Toolkit을 쓰면 `createSlice` 하나로 상태와 변경 로직을 묶을 수 있습니다. 코드가 좀 길어 보이지만, 상태가 어디서 어떻게 바뀌는지 추적하기에 좋다.

---

## Zustand

<aside>
🤍 **Zustand**

React의 Context API만으로 전역 상태를 관리할 때의 단점을 보완하는 경량 상태 관리 라이브러리로, 
**중앙 집중형 스토어**를 활용해 상태를 효율적으로 관리함.

Context API와 달리 **전역 상태를 컴포넌트 외부에서 관리**하여, 성능 최적화와 리렌더링 문제를 효과적으로 해결합니다.

https://zustand-demo.pmnd.rs/

</aside>

### Zustand의 특징

1. 간단하고 빠르게 상태를 정의할 수 있다.
2. 라이브러리의 크기가 작다 (1kb 번들기준으로 안팎이다. 그래서 가벼워서 요새 굉장히 많이 쓰임
    - 핵심 로직 코드 수가 적다
3. 타입스크립트 기반으로 작성되어 있다.
4. Context API를 사용할 때와 달리 상태 변경시 불필요한 리렌더링을 제어할 수 있다.
5. 미들웨어를 지원한다.
    - 스토어 데이터를 영구히 보존할 수 있는 persist
    - 복잡한 객체를 관리하기 쉽게 도와주는 immer

- 장점: 코드가 짧고 직관적이다. Selector 쓰면 리렌더링 제어도 쉽다.
- 단점: 너무 자유로워서 규칙 없이 막 쓰면 나중에 큰일남

```jsx
// store/useTodoStore.js
import { create } from "zustand";

//create 함수 하나로 스토어와 훅을 동시에 생성
export const useTodoStore = create((set) => ({
  todos: [], // 상태 변수 
  //상태 변경함수
  addTodo: (text) =>
    set((state) => ({ //set으로 상태 업데이트
      todos: [...state.todos, { id: Date.now(), text, done: false }],
    })),
  
}));
```

`create` 함수 안에 데이터(`todos`)와 함수(`addTodo`)를 같이 넣으면 끝이다. 컴포넌트에서는 `useTodoStore`를 바로 호출해서 사용 가능하다.

## Jotai

![image.png](%EB%B0%95%20%EC%9B%90%20-%20%EC%A0%84%EC%97%AD%20%EC%83%81%ED%83%9C%20%EA%B4%80%EB%A6%AC%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/image%201.png)

<aside>
🤍 React의 useState처럼 간단한 API를 제공하며, **상태의 최소 단위(atom)**를 중심으로 관리하는 경량 상태 관리 라이브러리.

파생 상태와 비동기 상태 관리도 손쉽게 구현 가능.

https://jotai.org/

</aside>

### Jotai의 특징

1. **간단한 API**:
    - Jotai 의 기본 단위인 Atom과 이를 사용하는 useAtom 훅이 React useState 방식과 매우 유사함.
2. **작고 가벼움**:
    - 패키지 크기가 매우 작음.
    - React와의 의존성이 강해 다른 추가적인 설정이 필요하지 않음.
3. **비동기 상태 관리 지원**:
    - 비동기 상태(async atom)를 쉽게 처리할 수 있으며, 이를 통해 데이터 페칭 로직 등을 간단히 구현할 수 있습니다.

## Atom

<aside>
🤍 Jotai에서 상태를 정의하는 **기본 단위**

</aside>

```tsx
import { atom } from "jotai";

// Atom 생성
const countAtom = atom(0); // 초기값은 0
```

## **useAtom**

<aside>
🤍 **Jotai 상태를 읽고 업데이트하는 React 훅
Atom과 함께 사용함**

</aside>

```tsx
import React from "react";
import { atom, useAtom } from "jotai";

// Atom 생성
const countAtom = atom(0);

function Counter() {
  const [count, setCount] = useAtom(countAtom); //usestate와 같은문법

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <button onClick={() => setCount(count - 1)}>Decrement</button>
    </div>
  );
}

export default Counter;
```

## Recoli

### 3-4. Recoil (리코이는 더이상 유지보수가 되지 않아서 이제 사용하지 않는다. )

![Untitled](%EB%B0%95%20%EC%9B%90%20-%20%EC%A0%84%EC%97%AD%20%EC%83%81%ED%83%9C%20%EA%B4%80%EB%A6%AC%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/Untitled.png)

<aside>
🤍 페이스북에서 만든 리액트를 
위한 상태 관리 라이브러리

→ 리액트 훅 기반으로 상태 관리를 할 수 있게 해준 대표적인 라이브러리

</aside>

<aside>
⛔

- Recoil은 Meta(구 페이스북)에서 만든 상태 관리 라이브러리
- 2025년 1월 2일 기준 GitHub 저장소는 archive 상태
    - 또한 React 19 RC와의 호환성 이슈도 보고되어 있음.
- 따라서 새 프로젝트에서 사용할 때는 **`다른 대안`**(Zustand, Jotai, Redux Toolkit 등)을 고려할 것!
</aside>

**🤔 redux와 무엇이 다른걸까?**

1. 러닝 커브가 낮다.
2. 상태를 직접 변경하고 읽을 수 있다.
3. 비동기적인 상태를 처리하기에 더 적합하다.
4. 필요한 만큼 상태 조각(atom)을 정의하고, 자유롭게 구성할 수 있다.

<aside>
📚 원자(Atom)에서 선택기(selector)를 거쳐 React 구성요소로 흐르는 데이터 흐름 그래프를 만드는 것
Atom은 구성요소가 구독할 수 있는 상태 단위
selector는 여러 상태(Atom)를 조합한 새로운 상태

</aside>

```jsx
import { atom, useRecoilState } from "recoil";

const textState = atom({
  key: "textState",
  default: "",
});

function Input() {
  const [text, setText] = useRecoilState(textState);

  return (
    <input
      value={text}
      onChange={(e) => setText(e.target.value)}
    />
  );
}
```

---

## 전역 상태 라이브러리 비교

![스크린샷 2025-12-25 오후 4.54.39.png](%EB%B0%95%20%EC%9B%90%20-%20%EC%A0%84%EC%97%AD%20%EC%83%81%ED%83%9C%20%EA%B4%80%EB%A6%AC%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2025-12-25_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.54.39.png)

## 최종 요약

**그래서 뭘 쓰라는 걸까?**

정답은 없다.

상황에 맞게, 프로젝트에 맞게, 팀 컨벤션에 맞게 잘 선택해서 사용할 것.

<aside>
❓

**전역 상태 관리 도구 선택 시 고려 사항**

1. **프로젝트 요구 사항**: 상태가 얼마나 복잡한가?
2. **팀의 기술 스택**: 팀원들이 익숙한 도구는 무엇인가?
3. **미래 유지보수성**: 상태 관리의 확장 가능성과 코드 가독성.

... 등등

</aside>

**하지만 가장 중요한 건 전역 상태 관리가 정말 필요한가 고민해봐야함**
