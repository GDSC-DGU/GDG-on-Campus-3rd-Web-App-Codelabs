# 윤찬영 - 서비스 워커와 캐싱 전략

---

## 지난 코드랩

- PWA 코드랩
- install 시 HTML/CSS/JS 프리캐싱 → 오프라인에서도 화면 렌더링
- DevTools 오프라인 체크 후 새로고침 → 네트워크 끊어도 앱 동작 확인

### 궁금증?

- 서비스 워커가 브라우저 내부에서 어디에서 동작되는지?
- 코드 수정 후 새로고침해도 화면이 안 바뀌는 이유?
- 미리 정해 둔 화면 말고는 오프라인에서 못 보나?

### 세미나 목표

- 서비스 워커 구조: 메인 스레드 vs 워커 스레드, 네트워크 프록시 구조
- 업데이트/좀비 문제: 라이프사이클, Waiting 상태, skipWaiting/clients.claim 개념
- 캐싱 전략 선택: 프리캐싱 vs 런타임 캐싱, Cache First / Network First / Stale-While-Revalidate

---

## 1. 왜 서비스 워커인가

### 기존 웹의 태생적 한계

네트워크 끊기면 바로 에러 화면 뜨고, 매번 같은 리소스를 다시 받아서 느리고, 푸시 알림 같은 것도 잘 안 됨.

이런 문제를 해결하기 위해 브라우저 안에 ‘우리만의 프록시 레이어’를 여는 기술 → 서비스 워커

- **프록시 레이어(Proxy Layer)란?**
    
    브라우저와 서버 사이의 **중간 관리자** 역할 수행
    
    네트워크 요청을 가로채서 **개발자가 원하는 대로 응답을 조작** 가능
    

---

## 2. 서비스 워커 한 줄 정의

브라우저 백그라운드에서 실행되는 독립적인 자바스크립트 스레드

메인 스레드와는 분리되어 있고, 네트워크 요청을 가로채서 **캐시에서 줄지, 네트워크에 갈지**를 결정하는 일종의 네트워크 프록시 역할을 함.

### Main vs Worker

- **메인 스레드**
    - 역할: UI 렌더링, DOM 조작, 클릭 이벤트 처리
    - 한계: 무거운 작업 시 화면 버벅임 발생
- **서비스 워커 스레드**
    - 역할: **네트워크 요청 가로채기(Fetch Proxy)**, 캐시 관리, 백그라운드 동기화
    - 특징: **DOM 접근 불가**, UI와 별도로 독립 동작 (탭을 닫아도 살아있음)

---

## 3. 아키텍처: 메인 스레드 ↔ 프록시 레이어

원래 페이지 → 네트워크 → 서버로 바로 가던 요청 사이에,  서비스 워커라는 프록시 레이어가 하나 더 끼는 것

<aside>

**[Normal Flow]**

**Web Page**

       ↓   (Request)

**Network** 

       ↓ 

   **Server**

</aside>

<aside>

**[Service Worker Flow]**

**Web Page** 

       ↓   (Request)

 **Service Worker (Proxy)** 

       ↓   (Decision)

 **Cache OR Network**

</aside>

### 단계별 동작

1. **Register (등록)** Main Thread
    - `index.js`에서 워커 파일을 브라우저에 등록하던 과정
    - 이 단계가 실행되어야 별도의 **워커 스레드**가 생성됨
    - 코드
        
        ```jsx
        // index.js (Main Thread)
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('/sw.js') 
          // /sw.js 파일을 다운로드하고 파싱을 시작함
            .then(() => console.log('Service Worker Registered'))
            .catch((err) => console.log('Registration Failed', err));
        }
        ```
        
2. **Install (설치)** Worker Thread
    - 리소스(HTML, CSS)를 미리 다운로드해 캐시에 저장 (**Pre-caching**) → 핵심 자원을 미리 쟁여둠
    - `self.addEventListener('install', ...)` 내의 `cache.addAll([])` 로직
    - 코드
        
        ```jsx
        // service-worker.js
        
        const CACHE_NAME = 'my-site-cache-v1';
        const urlsToCache = [
          '/',
          '/styles/main.css',
          '/script/main.js'
        ];
        
        self.addEventListener('install', event => {
          // 1. waitUntil: "캐싱이 다 끝날 때까지 설치를 완료하지 말고 기다려!"
          event.waitUntil(
            caches.open(CACHE_NAME) // 2. Cache Storage를 열고
              .then(cache => {
                console.log('Opened cache');
                return cache.addAll(urlsToCache); // 3. 지정한 파일들을 한 번에 저장
              })
          );
        });
        ```
        
3. **Fetch (가로채기)** Worker Thread
    - 설치가 끝나고 활성화되면, 페이지의 모든 네트워크 요청이 서비스 워커를 거쳐감. → 중간 관리자 역할
    - `event.respondWith()`로 **"캐시 줄까? 서버 갈까?"** 결정
    - 코드
        
        ```jsx
        self.addEventListener('fetch', event => {
          // respondWith: "브라우저야, 네트워크 대신 내가 주는 거 받아!"
          event.respondWith(
            caches.match(event.request) // 1. 먼저 캐시를 뒤져본다.
              .then(response => {
                // 2. 캐시에 있으면(response) 그거 주고, 없으면 네트워크(fetch)로 간다.
                // 이것이 바로 "Cache First" 전략 + "Network Fallback"
                return response || fetch(event.request);
              })
          );
        });
        ```
        

---

## 4. 라이프사이클 & 좀비 문제

**"코드를 수정하고 배포했는데, 왜 화면은 그대로일까?"**

### 라이프사이클?

→ 설치만 된다고 바로 새 코드가 적용되는 게 아니라, ‘세대 교체’ 과정이 있음

- Install: 새 워커가 처음 설치되며 프리캐싱 실행.
- Waiting: 기존 워커가 아직 탭을 제어 중이면, 새 워커는 ‘대기실’에 머무름.
- Activate: 기존 탭이 정리되면 새 워커가 활성화, 이전 캐시 정리 후 제어 시작.

### 좀비 워커 현상

그래서 자주 나오는 현상이 코드를 고쳤는데 새로고침을 해도 화면이 안 바뀌는 것

이미 열린 탭은 이전 서비스 워커가 계속 제어하고 있고, 새 워커는 Waiting 상태라서, 

캐시도 예전 번들을 주고 있으니까 마치 ‘좀비 버전’이 남아 있는 것처럼 보임.

- 해결 키워드
    - `skipWaiting()`: "대기하지 말고 즉시 교대해!" (강제 대기 해제)
        
        새 워커를 바로 활성화하지만, 버전 불일치 리스크 있음.
        
    - `clients.claim()`: "교대했으면 당장 현재 열린 탭들을 조종해!" (제어권 탈취)
        
        활성화된 워커가 즉시 모든 탭을 제어.
        
    - 실무 패턴: “새 버전 있습니다 → 새로고침 안내 → 동의 시 강제 리로드” UI로 안전하게 전환.

---

## 5. 런타임 캐싱

프리캐싱은 미리 리소스를 다운로드해 캐시에 저장하기 때문에, 지정된 페이지만 오프라인에서 볼 수 있다.

실행 중에 동적으로 페이지를 저장하고 싶은데? → **런타임 캐싱!!**

**"사용자가 클릭해서 들어간 페이지를, 서비스 워커가 몰래 복사해서 캐시에 넣는다."**

이 로직은 `install`이 아니라 **`fetch` 이벤트 리스너** 안에서 구현함.

네트워크 요청이 성공해서 응답이 돌아오면, 그 응답을 복제해서 캐시에 `put` 하는 방식

- 코드
    
    ```jsx
    self.addEventListener('fetch', event => {
      event.respondWith(
        // 1. 일단 네트워크로 요청을 보냄 (Network First 전략 예시)
        fetch(event.request)
          .then(response => {
            // 2. 응답이 유효한지 체크 (에러거나, 내 사이트가 아니면 캐시 안 함)
            if (!response || response.status !== 200 || response.type !== 'basic') {
              return response;
            }
    
            // ★ 핵심 Deep Dive: 응답을 복제(Clone)해야 함!
            // 이유: 응답(Response) 데이터는 '스트림(Stream)'이라서 한 번 읽으면 사라짐.
            // 하나는 브라우저(화면)에 주고, 하나는 캐시에 넣어야 하니까 복제가 필수.
            const responseToCache = response.clone();
    
            caches.open('my-dynamic-cache-v1')
              .then(cache => {
                // 3. 동적으로 캐시에 저장 (URL 키, 응답 값)
                cache.put(event.request, responseToCache);
              });
    
            return response; // 4. 원본은 화면으로 보냄
          })
          .catch(() => {
            // 5. 네트워크 실패 시 캐시에서 꺼내줌 (오프라인 대응)
            return caches.match(event.request);
          })
      );
    });
    ```
    

### **프리캐싱 vs 런타임 캐싱 비교**

| **구분** | **프리캐싱 (Pre-caching)** | **런타임 캐싱 (Runtime Caching)** |
| --- | --- | --- |
| **언제?** | 앱이 처음 설치(Install)될 때 | 사용자가 페이지를 요청(Fetch)할 때 |
| **무엇을?** | 개발자가 **지정한** 핵심 파일 (App Shell) | 사용자가 **방문한** 페이지/이미지 |
| **목적** | 오프라인 실행을 위한 최소한의 기반 | 방문했던 페이지를 오프라인에서 다시 볼 수 있게 함 |
| **메서드** | `cache.addAll(['/a', '/b'])` | `cache.put(req, res)` |
- 동작 흐름
    1. **Request:** 사용자가 `/article/1` 페이지 접속
    2. **Fetch:** 서비스 워커가 네트워크에서 데이터를 받아옴
    3. **Clone & Cache:** 받아온 데이터를 **복사**해서 동적 캐시 저장소에 `put`
    4. **Return:** 원본 데이터는 사용자 화면에 출력
    5. **Offline:** 나중에 인터넷 끊고 `/article/1` 다시 가면? → **캐시에서 나옴!**

### 실무 캐싱 전략

**① Cache First (캐시 우선)**

- 코드 로직: `캐시 확인` → `있으면 반환` → `없으면 네트워크`
- Use Case: 로고, 폰트, 라이브러리 (변하지 않는 정적 자원)
- Code Snippet:
    
    ```jsx
    return response || fetch(event.request);
    ```
    

**② Network First (네트워크 우선)**

- 코드 로직: `네트워크 요청` → `성공하면 반환 & 캐시 저장` → `실패하면 캐시(Fallback)`
- Use Case: 뉴스 피드, 실시간 가격, API 응답 (최신 데이터 중요)
- Code Snippet:
    
    ```jsx
    return fetch(event.request).catch(() => caches.match(event.request));
    ```
    

**③ Stale-While-Revalidate (SWR)**

- 코드 로직: `캐시 즉시 반환` → `(뒤에서) 네트워크 요청` → `캐시 최신화`
- Use Case: 아바타 이미지, 소셜 미디어 피드 (속도와 최신성 모두 중요)
- Code Snippet:
    
    ```jsx
    event.respondWith(
      caches.open(CACHE_NAME).then(async (cache) => {
        const cachedResponse = await cache.match(event.request);
        // 1. 네트워크 요청은 무조건 보낸다 (캐시 갱신용)
        const fetchPromise = fetch(event.request).then((networkResponse) => {
          cache.put(event.request, networkResponse.clone());
          return networkResponse;
        });
        // 2. 캐시가 있으면 바로 주고, 없으면 네트워크 응답을 기다린다
        return cachedResponse || fetchPromise;
      })
    );
    ```
    

---

## 정리

- **Architecture:** 서비스 워커는 요청을 가로채는 **프록시**다.
- **Lifecycle:** 업데이트가 안 되면 `skipWaiting`을 기억해라.
- **Strategy:** 상황에 맞춰 **SWR** 같은 똑똑한 전략을 골라 쓰자.
